

/************************************************************************/
/* const 用法
/************************************************************************/

/*
const在C语言中算是一个比较新的描述符，我们称之为常量修饰符，意即其所修饰
的对象为常量(immutable)。

1、函数体内修饰局部变量。
例：
void func(){
const int a=0;
}

首先，我们先把const这个单词忽略不看，那么a是一个int类型的局部自动变量，
我们给它赋予初始值0。

然后再看const.

const作为一个类型限定词，和int有相同的地位。
const int a;
int const a;
是等价的。于是此处我们一定要清晰的明白，const修饰的对象是谁，是a,和int没
有关系。const 要求他所修饰的对象为常量，不可被改变，不可被赋值，不可作为
左值（l-value)。
这样的写法也是错误的。
const int a;
a=0;
这是一个很常见的使用方式：
const double pi=3.14;
在程序的后面如果企图对pi再次赋值或者修改就会出错。

然后看一个稍微复杂的例子。
const int* p;
还是先去掉const 修饰符号。
注意，下面两个是等价的。
int* p;
int *p;
其实我们想要说的是，*p是int类型。那么显然，p就是指向int的指针。
同理
const int* p;
其实等价于
const int (*p);
int const (*p);
即，*p是常量。也就是说，p指向的数据是常量。
于是
p+=8; //合法
*p=3; //非法，p指向的数据是常量。

那么如何声明一个自身是常量指针呢？方法是让const尽可能的靠近p;
int* const p;
const右面只有p,显然，它修饰的是p,说明p不可被更改。然后把const去掉，可以
看出p是一个指向 int形式变量的指针。
于是
p+=8; //非法
*p=3; //合法

再看一个更复杂的例子，它是上面二者的综合
const int* const p;
说明p自己是常量，且p指向的变量也是常量。
于是
p+=8; //非法
*p=3; //非法

const 还有一个作用就是用于修饰常量静态字符串。
例如：
const char* name="David";
如果没有const,我们可能会在后面有意无意的写name[4]='x'这样的语句，这样会
导致对只读内存区域的赋值，然后程序会立刻异常终止。有了 const,这个错误就
能在程序被编译的时候就立即检查出来，这就是const的好处。让逻辑错误在编译
期被发现。

const 还可以用来修饰数组
const char s[]="David";
与上面有类似的作用。

2、在函数声明时修饰参数
来看实际中的一个例子。
NAME
memmove -- copy byte string

LIBRARY
Standard C Library (libc, -lc)

SYNOPSIS
#include <string.h>

void *
memmove(void *dst, const void *src, size_t len);

这是标准库中的一个函数，用于按字节方式复制字符串（内存）。
它的第一个参数，是将字符串复制到哪里去（dest),是目的地，这段内存区域必须
是可写。
它的第二个参数，是要将什么样的字符串复制出去，我们对这段内存区域只做读
取，不写。
于是，我们站在这个函数自己的角度来看，src 这个指针，它所指向的内存内所存
储的数据在整个函数执行的过程中是不变。于是src所指向的内容是常量。于是就
需要用const修饰。
例如，我们这里这样使用它。
const char* s="hello";
char buf[100];
memmove(buf,s,6); //这里其实应该用strcpy或memcpy更好

如果我们反过来写，
memmove(s,buf,6);
那么编译器一定会报错。事实是我们经常会把各种函数的参数顺序写反。事实是编
译器在此时帮了我们大忙。如果编译器静悄悄的不报错，(在函数声明处去掉
const即可),那么这个程序在运行的时候一定会崩溃。

这里还要说明的一点是在函数参数声明中const一般用来声明指针而不是变量本身。
例如，上面的size_t len,在函数实现的时候可以完全不用更改len的值，那么是否
应该把len也声明为常量呢？可以，可以这么做。我们来分析这么做有什么优劣。
如果加了const,那么对于这个函数的实现者，可以防止他在实现这个函数的时候修
改不需要修改的值(len),这样很好。
但是对于这个函数的使用者，
1。这个修饰符号毫无意义，我们可以传递一个常量整数或者一个非常量整数过
去，反正对方获得的只是我们传递的一个copy。
2。暴露了实现。我不需要知道你在实现这个函数的时候是否修改过len的值。

所以，const一般只用来修饰指针。

再看一个复杂的例子
int execv(const char *path, char *const argv[]);
着重看后面这个，argv.它代表什么。
如果去掉const,我们可以看出
char * argv[];
argv是一个数组，它的每个元素都是char *类型的指针。
如果加上const.那么const修饰的是谁呢？他修饰的是一个数组，argv[],意思就是
说这个数组的元素是只读的。那么数组的元素的是什么类型呢？是char *类型的指
针.也就是说指针是常量，而它指向的数据不是。
于是
argv[1]=NULL; //非法
argv[0][0]='a'; //合法


3、全局变量。
我们的原则依然是，尽可能少的使用全局变量。
我们的第二条规则 则是，尽可能多的使用const。
如果一个全局变量只在本文件中使用，那么用法和前面所说的函数局部变量没有什
么区别。
如果它要在多个文件间共享，那么就牵扯到一个存储类型的问题。

有两种方式。
1.使用extern
例如
// file1.h
extern const double pi;
// file1.c 
const double pi=3.14;
然后其他需要使用pi这个变量的，包含file1.h
#include "file1.h"
	或者，自己把那句声明复制一遍就好。
	这样做的结果是，整个程序链接完后，所有需要使用pi这个变量的共享一个存储区域。

	2.使用static,静态外部存储类
	// constant.h 
	static const pi=3.14;
需要使用这个变量的*.c文件中，必须包含这个头文件。
	前面的static一定不能少。否则链接的时候会报告说该变量被多次定义。
	这样做的结果是，每个包含了constant.h的*.c文件，都有一份该变量自己的copy,
	该变量实际上还是被定义了多次，占用了多个存储空间，不过在加了static关键字
	后，解决了文件间重定义的冲突。
	坏处是浪费了存储空间，导致链接完后的可执行文件变大。但是通常，这个，小小
	几字节的变化，不是问题。
	好处是，你不用关心这个变量是在哪个文件中被初始化的。


	最后，说说const的作用。
	const 的好处，是引入了常量的概念，让我们不要去修改不该修改的内存。直接的
	作用就是让更多的逻辑错误在编译期被发现。所以我们要尽可能的多使用const。
	但是很多人并不习惯使用它，更有甚者，是在整个程序 编写／调试 完后才补
	const。如果是给函数的声明补const,尚好。如果是给 全局／局部变量补const,那
	么……那么，为时已晚，无非是让代码看起来更漂亮了。
*/